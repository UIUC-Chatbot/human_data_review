[
  {
    "textbook-paragraph": "\n\nThe ability to detect any single bit error is certainly useful.\nHowever, so far we have only shown how to protect ourselves when we\nwant to represent decimal digits.  Do we need to develop a separate\nerror-tolerant representation for every type of information that\nwe might want to represent?  Or can we instead come up with a more\ngeneral approach?\n\nThe answer to the second question is yes: we can, in fact, systematically\ntransform any representation into a representation that allows detection of a\nsingle bit error.  The key to this transformation is the idea of\n{ parity}.\n\n\nConsider an arbitrary representation for some type of information.\nBy way of example, we use the {3-bit} unsigned representation.\nFor each pattern used in the representation, we can count the number\nof 1s.  The resulting count is either odd or even.  By adding an extra\nbit---called a { parity bit}---to the representation, and \nselecting the parity bit's value \nappropriately for each bit pattern, we can ensure that the count of 1s\nis odd (called { odd parity}) or even (called { even parity})\nfor all values represented.  The idea is\n\nillustrated in the table\nto the right for the {3-bit} unsigned representation.  The parity\nbits are shown in bold.\n\n\n{c|c|c|c|c}\nvalue      &   3-bit & number& with odd& with even \nrepresented& unsigned& of 1s & parity  & parity  \n0& 000& 0& 000{ 1}& 000{ 0}\n1& 001& 1& 001{ 0}& 001{ 1}\n2& 010& 1& 010{ 0}& 010{ 1}\n3& 011& 2& 011{ 1}& 011{ 0}\n4& 100& 1& 100{ 0}& 100{ 1}\n5& 101& 2& 101{ 1}& 101{ 0}\n6& 110& 2& 110{ 1}& 110{ 0}\n7& 111& 3& 111{ 0}& 111{ 1}\n\n\n\nEither approach to selecting the parity bits ensures that any single\nbit error can be detected.  For example, if we choose to use odd\nparity, a single\nbit error changes either a 0 into a 1 or a 1 into a 0.\nThe number of 1s in the resulting error pattern thus\ndiffers by exactly one from the original pattern, and the parity of\nthe error pattern is even.  But all valid patterns have odd parity,\nso any single bit error can be detected by simply counting the number\nof 1s.\n\n\n",
    "GPT-3-Generations": {
      "question": "\nWhich of the following is true about error-tolerant representation?\n\nA) It is not possible to systematically transform any representation into a representation that allows detection of a single bit error.\nB) The key to this transformation is the idea of parity.\nC) It is possible to systematically transform any representation into a representation that allows detection of a single bit error, but the key to this transformation is not the idea of parity.\nD) It is possible to systematically transform any representation into a representation that allows detection of multiple bit errors, but the key to this transformation is the idea of parity.",
      "answer": "\nThe answer is B."
    }
  }
]